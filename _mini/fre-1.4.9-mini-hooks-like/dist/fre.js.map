{"version":3,"sources":["dist/fre.js"],"names":["fre","exports","arrayfy","arr","Array","isArray","isSame","a","b","type","isNew","o","n","k","merge","out","i","defer","Promise","cb","resolve","then","setTimeout","h","props","rest","children","length","arguments","push","vnode","pop","nodeValue","key","updateProperty","element","name","value","newValue","style","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","updateElement","newProps","Object","keys","filter","forEach","cursor","useState","initState","useReducer","reducer","current","getWIP","setter","this","state","scheduleWork","bind","useMemo","inputs","hasChaged","oldInputs","some","v","isMounted","options","HOST","HOOK","ROOT","PLACE","REPLACE","UPDATE","DELETE","updateQueue","nextWork","pendingCommit","currentFiber","fiber","workLoop","update","shift","performWork","commitWork","patches","p","parentFiber","parent","tag","base","dom","child","insertPoint","patchTag","effect","removeChild","alternate","after","nextSibling","firstChild","insertBefore","commit","WIP","reconcileChildren","updateHOOK","end","document","createTextNode","createElement","oldPoint","updateHost","completeWork","sibling","fiberize","item","hashfy","oldFibers","newFibers","reused","newFiber","oldFiber","prevFiber","createFiber","data","concat","createContext","init","set","context","subscribe","fn","render","el","useContext","ctx","setContext","useEffect"],"mappings":"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","sourcesContent":["var fre = (function (exports) {\n  'use strict';\n\n  const arrayfy = arr => (!arr ? [] : Array.isArray(arr) ? arr : [arr]);\r\n\r\n  const isSame = (a, b) =>\r\n    a.type === b.type || typeof a.type === typeof b.type;\r\n\r\n  const isNew = (o, n) => k =>\r\n    k !== 'children' && k !== 'key' && o[k] !== n[k];\r\n\r\n  function hashfy (arr) {\r\n    let out = {};\r\n    let i = 0;\r\n    arrayfy(arr).forEach(item => {\r\n      let key = ((item || {}).props || {}).key;\r\n      key ? (out['.' + key] = item) : (out['.' + i] = item) && i++;\r\n    });\r\n    return out\r\n  }\r\n\r\n  function merge (a, b) {\r\n    let out = {};\r\n    for (var i in a) out[i] = a[i];\r\n    for (var i in b) out[i] = b[i];\r\n    return out\r\n  }\r\n  const defer =\r\n    typeof Promise === 'function' ? cb => Promise.resolve().then(cb) : setTimeout;\n\n  function h (type, props) {\n    let rest = [];\n    let children = [];\n    let length = arguments.length;\n\n    while (length-- > 2) rest.push(arguments[length]);\n\n    while (rest.length) {\n      let vnode = rest.pop();\n      if (vnode && vnode.pop) {\n        for (length = vnode.length; length--;) rest.push(vnode[length]);\n      } else if (vnode === null || vnode === true || vnode === false) {\n        vnode = { type: () => {} };\n      } else if (typeof vnode === 'function') {\n        children = vnode;\n      } else {\n        children.push(\n          typeof vnode === 'object'\n            ? vnode\n            : { type: 'text', props: { nodeValue: vnode } }\n        );\n      }\n    }\n    return {\n      type,\n      props: merge(props, { children }),\n      key: props && props.key\n    }\n  }\n\n  function updateProperty (element, name, value, newValue) {\n    if (name === 'style') {\n      for (key in newValue) {\n        let style = !newValue || !newValue[key] ? '' : newValue[key];\n        element[name][key] = style;\n      }\n    } else if (name[0] === 'o' && name[1] === 'n') {\n      name = name.slice(2).toLowerCase();\n      if (value) {\n        element.removeEventListener(name, value);\n      }\n      element.addEventListener(name, newValue);\n    } else {\n      element.setAttribute(name, newValue);\n    }\n  }\n\n  function updateElement (element, props, newProps) {\n    Object.keys(newProps)\n      .filter(isNew(props, newProps)) //进行浅比较和过滤\n      .forEach(key => {\n        if (key === 'value' || key === 'nodeValue') {\n          element[key] = newProps[key];\n        } else {\n          updateProperty(element, key, props[key], newProps[key]);\n        }\n      });\n  }\n\n  function createElement (fiber) {\n    const element =\n      fiber.type === 'text'\n        ? document.createTextNode('')\n        : document.createElement(fiber.type);\n    updateElement(element, [], fiber.props);\n    return element\n  }\n\n  let cursor = 0;\n\n  function update(key, reducer, value) {\n    const current = this ? this : getWIP();\n    value = reducer ? reducer(current.state[key], value) : value;\n    current.state[key] = value;\n    scheduleWork(current);\n  }\n  function resetCursor() {\n    cursor = 0;\n  }\n  function useState(initState) {\n    return useReducer(null, initState)\n  }\n  function useReducer(reducer, initState) {\n    let current = getWIP();\n    if (!current) return [initState, setter]\n    let key = '$' + cursor;\n    let setter = update.bind(current, key, reducer);\n    cursor++;\n    let state = current.state || {};\n    if (key in state) {\n      return [state[key], setter]\n    } else {\n      current.state[key] = initState;\n      return [initState, setter]\n    }\n  }\n\n  function useEffect(cb, inputs) {\n    let current = getWIP();\n    if (current) current.effect = useMemo(cb, inputs);\n  }\n\n  function useMemo(cb, inputs) {\n    return () => {\n      let current = getWIP();\n      if (current) {\n        let hasChaged = inputs\n          ? (current.oldInputs || []).some((v, i) => inputs[i] !== v)\n          : true;\n        if (inputs && !inputs.length && !current.isMounted) {\n          hasChaged = true;\n          current.isMounted = true;\n        }\n        if (hasChaged) cb();\n        current.oldInputs = inputs;\n      }\n    }\n  }\n\n  function createContext(init = {}) {\n    let context = init;\n    let set = {};\n    const update = context => {\n      for (let key in set) set[key](context);\n    };\n    const subscribe = (fn, name) => {\n      if(name in set) return\n      set[name] = fn;\n    };\n\n    return { context, update, subscribe, set }\n  }\n\n  function useContext(ctx) {\n    const [context, setContext] = useState(ctx.context);\n    const name = getWIP().type.name;\n    ctx.subscribe(setContext, name);\n    return [context, ctx.update]\n  }\n\n  const options = {};\r\n  const [HOST, HOOK, ROOT, PLACE, REPLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5, 6];\r\n\r\n  let updateQueue = [];\r\n  let nextWork = null;\r\n  let pendingCommit = null;\r\n  let currentFiber = null;\r\n\r\n  function render(vnode, el) {\r\n    let rootFiber = {\r\n      tag: ROOT,\r\n      base: el,\r\n      props: { children: vnode }\r\n    };\r\n    scheduleWork(rootFiber);\r\n  }\r\n\r\n  function scheduleWork(fiber) {\r\n    updateQueue.push(fiber);\r\n    defer(workLoop);\r\n  }\r\n\r\n  function workLoop() {\r\n    if (!nextWork && updateQueue.length) {\r\n      const update = updateQueue.shift();\r\n      if (!update) return\r\n      nextWork = update;\r\n    }\r\n    while (nextWork) {\r\n      nextWork = performWork(nextWork);\r\n    }\r\n\r\n    if (pendingCommit) {\r\n      options.commitWork\r\n        ? options.commitWork(pendingCommit)\r\n        : commitWork(pendingCommit);\r\n    }\r\n  }\r\n\r\n  function performWork(WIP) {\r\n    WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\r\n    if (WIP.child) return WIP.child\r\n    while (WIP) {\r\n      completeWork(WIP);\r\n      if (WIP.sibling) return WIP.sibling\r\n      WIP = WIP.parent;\r\n    }\r\n  }\r\n\r\n  function updateHost(WIP) {\r\n    if (!options.end && !WIP.base) {\r\n      WIP.base = createElement(WIP);\r\n    }\r\n\r\n    let parent = WIP.parent || {};\r\n    WIP.insertPoint = parent.oldPoint;\r\n    parent.oldPoint = WIP;\r\n\r\n    const children = WIP.props.children;\r\n    reconcileChildren(WIP, children);\r\n  }\r\n\r\n  function updateHOOK(WIP) {\r\n    WIP.props = WIP.props || {};\r\n    WIP.state = WIP.state || {};\r\n    currentFiber = WIP;\r\n    resetCursor();\r\n    const children = WIP.type(WIP.props);\r\n    reconcileChildren(WIP, children);\r\n    currentFiber.patches = WIP.patches;\r\n  }\r\n  function fiberize(children, WIP) {\r\n    return (WIP.children = hashfy(children))\r\n  }\r\n\r\n  function reconcileChildren(WIP, children) {\r\n    const oldFibers = WIP.children;\r\n    const newFibers = fiberize(children, WIP);\r\n    let reused = {};\r\n\r\n    for (let k in oldFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = oldFibers[k];\r\n      if (newFiber && isSame(newFiber, oldFiber)) {\r\n        reused[k] = oldFiber;\r\n      } else {\r\n        oldFiber.patchTag = DELETE;\r\n        WIP.patches.push(oldFiber);\r\n      }\r\n    }\r\n\r\n    let prevFiber = null;\r\n    let alternate = null;\r\n\r\n    for (let k in newFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = reused[k];\r\n\r\n      if (oldFiber) {\r\n        if (isSame(oldFiber, newFiber)) {\r\n          alternate = createFiber(oldFiber, {\r\n            patchTag: UPDATE\r\n          });\r\n\r\n          if (!options.end) newFiber.patchTag = UPDATE;\r\n          newFiber = merge(alternate, newFiber);\r\n          newFiber.alternate = alternate;\r\n          if (oldFiber.key) {\r\n            newFiber.patchTag = REPLACE;\r\n          }\r\n        }\r\n      } else {\r\n        newFiber = createFiber(newFiber, {\r\n          patchTag: PLACE\r\n        });\r\n      }\r\n      newFibers[k] = newFiber;\r\n      newFiber.parent = WIP;\r\n\r\n      if (prevFiber) {\r\n        prevFiber.sibling = newFiber;\r\n      } else {\r\n        WIP.child = newFiber;\r\n      }\r\n      prevFiber = newFiber;\r\n    }\r\n    if (prevFiber) prevFiber.sibling = null;\r\n  }\r\n\r\n  function createFiber(vnode, data) {\r\n    data.tag = typeof vnode.type === 'function' ? HOOK : HOST;\r\n    vnode.props = vnode.props || { nodeValue: vnode.nodeValue };\r\n    return merge(vnode, data)\r\n  }\r\n\r\n  function completeWork(fiber) {\r\n    if (!options.end && fiber.parent) {\r\n      fiber.parent.patches = (fiber.parent.patches || []).concat(\r\n        fiber.patches || [],\r\n        fiber.patchTag ? [fiber] : []\r\n      );\r\n    } else {\r\n      pendingCommit = fiber;\r\n    }\r\n  }\r\n\r\n  function commitWork(WIP) {\r\n    WIP.patches.forEach(p => commit(p));\r\n    nextWork = pendingCommit = null;\r\n  }\r\n\r\n  function commit(fiber) {\r\n    let parentFiber = fiber.parent;\r\n    while (parentFiber.tag == HOOK) {\r\n      parentFiber = parentFiber.parent;\r\n    }\r\n    const parent = parentFiber.base;\r\n    let dom = fiber.base || fiber.child.base;\r\n    const { insertPoint, patchTag } = fiber;\r\n    if (fiber.tag == HOOK) {\r\n      fiber.effect && fiber.effect();\r\n      if (patchTag == DELETE) parent.removeChild(dom);\r\n    } else if (patchTag == UPDATE) {\r\n      updateElement(dom, fiber.alternate.props, fiber.props);\r\n    } else if (patchTag == DELETE) {\r\n      parent.removeChild(dom);\r\n    } else {\r\n      let after = insertPoint\r\n        ? patchTag == PLACE\r\n          ? insertPoint.base.nextSibling\r\n          : insertPoint.base.nextSibling || parent.firstChild\r\n        : null;\r\n      if (after == dom) return\r\n      parent.insertBefore(dom, after);\r\n    }\r\n    parentFiber.patches = fiber.patches = [];\r\n  }\r\n\r\n  function getWIP() {\r\n    return currentFiber || null\r\n  }\n\n  exports.createContext = createContext;\n  exports.createElement = h;\n  exports.h = h;\n  exports.options = options;\n  exports.render = render;\n  exports.scheduleWork = scheduleWork;\n  exports.useContext = useContext;\n  exports.useEffect = useEffect;\n  exports.useMemo = useMemo;\n  exports.useReducer = useReducer;\n  exports.useState = useState;\n\n  return exports;\n\n}({}));\n//# sourceMappingURL=fre.js.map\n"]}